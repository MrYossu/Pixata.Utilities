@using System.Globalization
@using System.Linq
@typeparam TValue

<div class="hebrew-date-picker position-relative @Class" style="@WidthStyle">
  <div class="input-group">
    <input class="form-control" placeholder="dd/MM/yyyy or d MMM yyyy" value="@_textValue" readonly />
    <button class="btn" style="background-color: #e4e7eb" type="button" @onclick="ToggleCalendar">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="1em"
        height="1em"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
        aria-hidden="true">

        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>

        <line x1="8" y1="2" x2="8" y2="6"></line>
        <line x1="16" y1="2" x2="16" y2="6"></line>

        <line x1="3" y1="10" x2="21" y2="10"></line>

        <circle cx="7.5" cy="14" r="0.75"></circle>
        <circle cx="12" cy="14" r="0.75"></circle>
        <circle cx="16.5" cy="14" r="0.75"></circle>

        <circle cx="7.5" cy="18" r="0.75"></circle>
        <circle cx="12" cy="18" r="0.75"></circle>
        <circle cx="16.5" cy="18" r="0.75"></circle>
      </svg>
    </button>
  </div>
  @if (ShowDiagnostics) {
    <div class="mt-1"><small>@Diagnostics()</small></div>
  }

  @if (_calendarOpen) {
    <!-- overlay to capture outside clicks and close the popup -->
    <div style="position:fixed; inset:0; z-index:2000;" @onclick="CloseCalendar"></div>

    <div class="card" style="position:fixed; z-index:2001; width:320px; direction:ltr;">
      <div class="card-header d-flex justify-content-between align-items-center">
        <button type="button" class="btn btn-sm btn-link" @onclick="PrevHebrewMonth">‹</button>
        <div class="d-flex align-items-center gap-2">
          <strong>@_displayHebrewMonthName</strong>
          <select class="form-select form-select-sm" style="width:120px;" @bind="DisplayHebrewYear">
            @foreach (int y in Years) {
              <option value="@y">@y</option>
            }
          </select>
        </div>
        <button type="button" class="btn btn-sm btn-link" @onclick="NextHebrewMonth">›</button>
      </div>
      <div class="card-body p-2">
        <div class="small text-muted" style="display:grid; grid-template-columns:repeat(7,1fr); direction:rtl; text-align:right; gap:0.25rem;">
          <div style="padding-right: 8px;">&#x05D0;</div>
          <div style="padding-right: 8px;">&#x05D1;</div>
          <div style="padding-right: 8px;">&#x05D2;</div>
          <div style="padding-right: 8px;">&#x05D3;</div>
          <div style="padding-right: 8px;">&#x05D4;</div>
          <div style="padding-right: 8px;">&#x05D5;</div>
          <div style="padding-right: 8px;">&#x05E9;</div>
        </div>
        @foreach (var week in HebrewCalendarWeeks()) {
          <div class="mt-1" style="display:grid; grid-template-columns:repeat(7,1fr); direction:rtl; gap:0.5rem;">
            @foreach (int? hebDay in week) {
              if (hebDay.HasValue) {
                DateTime greg = _hc.ToDateTime(_displayHebrewYear, _displayHebrewMonth, hebDay.Value, 0, 0, 0, 0);
                bool isToday = greg.Date == DateTime.Today;
                bool isSelected = IsSelectedDate(greg.Date);
                <div class="text-end">
                  <button type="button" class="btn btn-sm @(isSelected ? "btn-primary text-white" : isToday ? "btn-outline-secondary" : "btn-light")" @onclick="() => SelectHebrewDay(hebDay.Value)">@hebDay.Value</button>
                </div>
              } else {
                <div></div>
              }
            }
          </div>
        }
      </div>
      <div class="card-footer d-flex justify-content-between">
        @if (typeof(TValue) == typeof(DateTime?)) {
          <button type="button" class="btn btn-sm btn-link" style="text-decoration: none" @onclick="ClearSelection">Clear</button>
        } else {
          <div></div>
        }
        <button type="button" class="btn btn-sm btn-link" style="text-decoration: none" @onclick="SelectToday">Today</button>
      </div>
    </div>
  }
</div>

@code {

  [Parameter]
  public TValue? Value { get; set; }

  [Parameter]
  public EventCallback<TValue> ValueChanged { get; set; }

  [Parameter]
  public DateTime MinDate { get; set; } = new(1584, 1, 1);

  [Parameter]
  public DateTime MaxDate { get; set; } = new(2238, 9, 29);

  [Parameter]
  public string Class { get; set; } = "";

  [Parameter]
  public string Width { get; set; } = "320px";

  private string WidthStyle =>
    $"width: {Width}";

  [Parameter]
  public bool ShowDiagnostics { get; set; }

  private readonly HebrewCalendar _hc = new();
  private int _hebrewYear;
  private int _hebrewMonth;
  private List<(int Number, string Name)> Months { get; set; } = [];
  private List<int> Years { get; set; } = [];

  private bool _calendarOpen;
  private string _textValue = "";
  private int _displayHebrewYear;
  private int _displayHebrewMonth;
  private string _displayHebrewMonthName = "";

  private int DisplayHebrewYear {
    get => _displayHebrewYear;
    set {
      if (_displayHebrewYear == value) {
        return;
      }
      _displayHebrewYear = value;
      int monthsInYear = _hc.GetMonthsInYear(_displayHebrewYear);
      if (_displayHebrewMonth > monthsInYear) {
        _displayHebrewMonth = monthsInYear;
      }
      BuildMonths();
      UpdateDisplayMonthName();
    }
  }

  protected override void OnInitialized() {
    Type targetType = typeof(TValue);
    if (targetType != typeof(DateTime) && targetType != typeof(DateTime?)) {
      throw new InvalidOperationException($"HebrewDatePicker only supports DateTime or DateTime? types. It cannot be used with {targetType.Name}");
    }
  }

  protected override void OnParametersSet() {
    base.OnParametersSet();
    InitializeFromValue();
  }

  private string Diagnostics() {
    DateTime src = SafeCurrentDate();
    int hy = _hc.GetYear(src);
    int hm = _hc.GetMonth(src);
    int hd = _hc.GetDayOfMonth(src);
    string mapped = Months.FirstOrDefault(m => m.Number == hm).Name ?? GetHebrewMonthName(hy, hm);
    return $"Source: {src:yyyy-MM-dd} -> Hebrew: {hd}/{hm}/{hy} -> mapped name: {mapped}";
  }

  private void InitializeFromValue() {
    DateTime? sourceOpt = GetCurrentValue();
    DateTime sourceForDisplay = sourceOpt ?? DateTime.Today;
    _hebrewYear = _hc.GetYear(sourceForDisplay);
    _hebrewMonth = _hc.GetMonth(sourceForDisplay);
    _displayHebrewYear = _hebrewYear;
    _displayHebrewMonth = _hebrewMonth;
    BuildYearRange();
    BuildMonths();
    UpdateDisplayMonthName();
    _textValue = sourceOpt.HasValue ? FormatHebrewDate(sourceOpt.Value) : "No date selected";
  }

  private void BuildYearRange() {
    int minYear = _hc.GetYear(MinDate);
    int maxYear = _hc.GetYear(MaxDate);
    if (minYear > maxYear) {
      (minYear, maxYear) = (maxYear, minYear);
    }
    Years = [];
    for (int y = minYear; y <= maxYear; y++) {
      Years.Add(y);
    }
    if (!Years.Contains(_displayHebrewYear)) {
      Years.Add(_displayHebrewYear);
      Years.Sort();
    }
  }

  private void BuildMonths() {
    Months = [];
    int monthsInYear = _hc.GetMonthsInYear(_displayHebrewYear);
    // Tishri-based ordering: 1 == Tishri
    if (monthsInYear == 13) {
      Months.Add((1, "\u05EA\u05E9\u05E8\u05D9")); //תשרי
      Months.Add((2, "\u05D7\u05E9\u05D5\u05DF")); //חשון
      Months.Add((3, "\u05DB\u05E1\u05DC\u05D5")); //כסלו
      Months.Add((4, "\u05D8\u05D1\u05EA")); //טבת
      Months.Add((5, "\u05E9\u05D1\u05D8")); //שבט
      Months.Add((6, "\u05D0\u05D3\u05E8 \u05D0")); //אדר א
      Months.Add((7, "\u05D0\u05D3\u05E8 \u05D1")); //אדר ב
      Months.Add((8, "\u05E0\u05D9\u05E1\u05DF")); //ניסן
      Months.Add((9, "\u05D0\u05D9\u05D9\u05E8")); //אייר
      Months.Add((10, "\u05E1\u05D9\u05D5\u05DF")); //סיון
      Months.Add((11, "\u05EA\u05DE\u05D5\u05D6")); //תמוז
      Months.Add((12, "\u05D0\u05D1")); //אב
      Months.Add((13, "\u05D0\u05DC\u05D5\u05DC")); //אלול
    } else {
      Months.Add((1, "\u05EA\u05E9\u05E8\u05D9")); //תשרי
      Months.Add((2, "\u05D7\u05E9\u05D5\u05DF")); //חשון
      Months.Add((3, "\u05DB\u05E1\u05DC\u05D5")); //כסלו
      Months.Add((4, "\u05D8\u05D1\u05EA")); //טבת
      Months.Add((5, "\u05E9\u05D1\u05D8")); //שבט
      Months.Add((6, "\u05D0\u05D3\u05E8")); //אדר
      Months.Add((7, "\u05E0\u05D9\u05E1\u05DF")); //ניסן
      Months.Add((8, "\u05D0\u05D9\u05D9\u05E8")); //אייר
      Months.Add((9, "\u05E1\u05D9\u05D5\u05DF")); //סיון
      Months.Add((10, "\u05EA\u05DE\u05D5\u05D6")); //תמוז
      Months.Add((11, "\u05D0\u05D1")); //אב
      Months.Add((12, "\u05D0\u05DC\u05D5\u05DC")); //אלול
    }
  }

  // days are computed per-month when rendering; no persistent Days collection required

  private void UpdateDisplayMonthName() =>
    _displayHebrewMonthName = Months.FirstOrDefault(m => m.Number == _displayHebrewMonth).Name ?? GetHebrewMonthName(_displayHebrewYear, _displayHebrewMonth);

  private string FormatHebrewDate(DateTime gregorian) {
    const char lrm = '\u200E';
    int hy = _hc.GetYear(gregorian);
    int hm = _hc.GetMonth(gregorian);
    int hd = _hc.GetDayOfMonth(gregorian);
    string monthName = Months.FirstOrDefault(m => m.Number == hm).Name ?? GetHebrewMonthName(hy, hm);
    return $"{lrm}{hd}{lrm} {monthName} {lrm}{hy}{lrm}";
  }

  private string GetHebrewMonthName(int year, int month) {
    int monthsInYear = _hc.GetMonthsInYear(year);
    if (monthsInYear == 13) {
      switch (month) {
        case 6:
          return "אדר א";
        case 7:
          return "אדר ב";
      }
    }
    return month switch {
      1 => "תשרי",
      2 => "חשון",
      3 => "כסלו",
      4 => "טבת",
      5 => "שבט",
      6 => "אדר",
      7 => "ניסן",
      8 => "אייר",
      9 => "סיון",
      10 => "תמוז",
      11 => "אב",
      12 => "אלול",
      _ => $"חודש {month}",
    };
  }

  private void ToggleCalendar() {
    _calendarOpen = !_calendarOpen;
    if (_calendarOpen) {
      DateTime refDate = GetCurrentValue() ?? DateTime.Today;
      _displayHebrewYear = _hc.GetYear(refDate);
      _displayHebrewMonth = _hc.GetMonth(refDate);
      BuildMonths();
      UpdateDisplayMonthName();
      if (GetCurrentValue().HasValue) {
        _textValue = FormatHebrewDate(refDate);
      } else {
        _textValue = "No date selected";
      }
    }
  }

  private void CloseCalendar() =>
    _calendarOpen = false;

  private void PrevHebrewMonth() {
    if (_displayHebrewMonth > 1) {
      _displayHebrewMonth -= 1;
    } else {
      _displayHebrewYear -= 1;
      _displayHebrewMonth = _hc.GetMonthsInYear(_displayHebrewYear);
    }
    BuildMonths();
    UpdateDisplayMonthName();
  }

  private void NextHebrewMonth() {
    int monthsInYear = _hc.GetMonthsInYear(_displayHebrewYear);
    if (_displayHebrewMonth < monthsInYear) {
      _displayHebrewMonth += 1;
    } else {
      _displayHebrewMonth = 1;
      _displayHebrewYear += 1;
    }
    BuildMonths();
    UpdateDisplayMonthName();
  }

  private IEnumerable<int?[]> HebrewCalendarWeeks() {
    int daysInMonth = _hc.GetDaysInMonth(_displayHebrewYear, _displayHebrewMonth);
    List<int?> cells = [];
    DateTime firstG = _hc.ToDateTime(_displayHebrewYear, _displayHebrewMonth, 1, 0, 0, 0, 0);
    int dow = (int)firstG.DayOfWeek; // Sunday=0
    for (int i = 0; i < dow; i++) {
      cells.Add(null);
    }
    for (int d = 1; d <= daysInMonth; d++) {
      cells.Add(d);
    }
    while (cells.Count % 7 != 0) {
      cells.Add(null);
    }
    List<int?[]> weeks = [];
    for (int i = 0; i < cells.Count; i += 7) {
      int?[] week = new int?[7];
      for (int j = 0; j < 7; j++) {
        week[j] = cells[i + j];
      }
      weeks.Add(week);
    }
    return weeks;
  }

  private async Task SelectHebrewDay(int hebDay) {
    DateTime dt = _hc.ToDateTime(_displayHebrewYear, _displayHebrewMonth, hebDay, 0, 0, 0, 0);
    await SetValue(dt);
    _textValue = FormatHebrewDate(dt);
    InitializeFromValue();
    _calendarOpen = false;
  }

  private async Task SelectToday() {
    DateTime dt = DateTime.Today;
    await SetValue(dt);
    _textValue = FormatHebrewDate(dt);
    InitializeFromValue();
    _calendarOpen = false;
  }

  private async Task ClearSelection() {
    await SetValue(null);
    _textValue = "No date selected";
    InitializeFromValue();
    _calendarOpen = false;
  }

  private DateTime? GetCurrentValue() {
    if (typeof(TValue) == typeof(DateTime)) {
      // If TValue is DateTime, then Value should never null, so we should be safe using !
      return (DateTime)(object)Value!;
    }
    if (typeof(TValue) == typeof(DateTime?)) {
      return Value is null ? null : (DateTime?)(object)Value;
    }
    return null;
  }

  private DateTime SafeCurrentDate() {
    DateTime candidate = GetCurrentValue() ?? DateTime.Today;
    if (candidate == default) {
      candidate = DateTime.Today;
    }
    DateTime minSupported = new(1583, 1, 1);
    DateTime maxSupported = new(2239, 9, 29, 23, 59, 59);
    DateTime minBound = MinDate > minSupported ? MinDate : minSupported;
    DateTime maxBound = MaxDate < maxSupported ? MaxDate : maxSupported;
    if (candidate < minBound) {
      return minBound;
    }
    if (candidate > maxBound) {
      return maxBound;
    }
    return candidate;
  }

  private bool IsSelectedDate(DateTime date) {
    DateTime? cur = GetCurrentValue();
    if (!cur.HasValue) {
      return false;
    }
    return cur.Value.Date == date.Date;
  }

  private async Task SetValue(DateTime? newValue) {
    if (typeof(TValue) == typeof(DateTime)) {
      Value = (TValue)(object)(newValue ?? default(DateTime));
      await ValueChanged.InvokeAsync(Value);
      return;
    }
    if (typeof(TValue) == typeof(DateTime?)) {
      Value = (TValue?)(object?)newValue;
      await ValueChanged.InvokeAsync(Value);
    }
  }

}