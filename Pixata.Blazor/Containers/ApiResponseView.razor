@using System.Net
@using Pixata.Blazor.Extensions
@using Pixata.Blazor.Notifications
@using static Pixata.Extensions.Yunit
@typeparam T
@inject PersistentStateHelper<ApiResponse<T>> StateHelper
@inject NavigationManager NavigationManager

@if (FeedbackType == ApiResponseViewFeedbackType.Notifications) {
  <NotificationArea NotificationHelper="NotificationHelper" />
}

@if (FeedbackType == ApiResponseViewFeedbackType.MessageView && MessagePosition == ApiResponseViewMessagePositions.Top) {
  <MessageView Message="@Message" Class="@MessageCssClass" />
}

@switch (_apiResponse.State) {
  case ApiResponseStates.Loading:
    @Loader(yunit)
    break;

  case ApiResponseStates.Success:
    <div style="@_arvSuccessStyle">
      @Success(_apiResponse.Data!)
    </div>
    @if (ManualLoading && !_manualLoadingComplete) {
      @Loader(yunit)
    }
    break;

  case ApiResponseStates.NotFound:
    @NotFound(yunit)
    break;

  case ApiResponseStates.Failure:
    @if (_apiResponse.Message.Contains($"{HttpStatusCode.Unauthorized}")) {
      @RequiresLogIn(_apiResponse.Message)
    } else {
      @Failure(_apiResponse.Message)
    }
    break;

  case ApiResponseStates.HttpFailure:
    @HttpFailure(_apiResponse.Message)
    break;

  case ApiResponseStates.ServiceUnavailable:
    @ServiceUnavailable(yunit)
    break;
}

@if (FeedbackType == ApiResponseViewFeedbackType.MessageView && MessagePosition == ApiResponseViewMessagePositions.Bottom) {
  <MessageView Message="@Message" Class="@MessageCssClass" />
}

@code {

  private ApiResponse<T> _apiResponse = new(ApiResponseStates.Loading);

  [Inject]
  public NotificationHelper NotificationHelper { get; set; } = null!;

  [Parameter]
  public string Key { get; set; } = "";

  [Parameter]
  public Func<Task<ApiResponse<T>>> LoadApiResponse { get; set; } = () => Task.FromResult(new ApiResponse<T>(ApiResponseStates.Success));

  [Parameter]
  public RenderFragment<T> Success { get; set; } = _ => @<div>
                                                          <h2>Big success</h2>
                                                          <div>You shouldn't see this, as the developer should have handled this case</div>
                                                        </div>;

  [Parameter]
  public RenderFragment<Yunit> Loader { get; set; } = ApiResponseViewConfig.Loader;

  [Parameter]
  public RenderFragment<Yunit> NotFound { get; set; } = ApiResponseViewConfig.NotFound;

  [Parameter]
  public RenderFragment<string> Failure { get; set; } = ApiResponseViewConfig.Failure;

  [Parameter]
  public RenderFragment<string> RequiresLogIn { get; set; } = ApiResponseViewConfig.RequiresLogIn;

  [Parameter]
  public RenderFragment<string> HttpFailure { get; set; } = ApiResponseViewConfig.HttpFailure;

  [Parameter]
  public RenderFragment<Yunit> ServiceUnavailable { get; set; } = ApiResponseViewConfig.ServiceUnavailable;

  [Parameter]
  public ApiResponseViewMessagePositions MessagePosition { get; set; } = ApiResponseViewConfig.MessagePosition;

  [Parameter]
  public ApiResponseViewFeedbackType FeedbackType { get; set; } = ApiResponseViewConfig.FeedbackType;

  [Parameter]
  public string MessageCssClass { get; set; } = "";

  [Parameter]
  public bool ManualLoading { get; set; }

  private bool _manualLoadingComplete;

  private string _arvSuccessStyle = "";

  public string Message { get; set; } = "";

  protected override async Task OnInitializedAsync() {
    _arvSuccessStyle = ManualLoading && !_manualLoadingComplete ? "position: absolute; left: 1000000px" : "";
    _apiResponse = await StateHelper.Get(LoadApiResponse, Key);
    if (_apiResponse.Message.Contains("Unauthorized")) {
      NavigationManager.NavigateTo($"{ApiResponseViewConfig.LogInUrl}?returnUrl=/{Uri.EscapeDataString(NavigationManager.ToBaseRelativePath(NavigationManager.Uri))}", forceLoad: true);
    }
  }

  public async Task Reload() =>
    _apiResponse = await LoadApiResponse();

  public T Data {
    get =>
      (_apiResponse.State == ApiResponseStates.Success
        ? _apiResponse.Data
        : default)!;
    set =>
      _apiResponse = _apiResponse with { Data = value };
  }

  public async Task Do<TOut>(Func<Task<ApiResponse<TOut>>> action, Action<TOut> onSuccess, Action<string>? onNotSuccess = null, bool changeStateOnNotSuccess = false) {
    Message = "";
    HandleResponse(await action(), onSuccess, onNotSuccess, changeStateOnNotSuccess);
  }

  public void HandleResponse<TOut>(ApiResponse<TOut> response, Action<TOut> onSuccess, Action<string>? onNotSuccess = null, bool changeStateOnNotSuccess = false) {
    switch (response.State) {
      case ApiResponseStates.Success:
        Message = "";
        onSuccess.Invoke(response.Data!);
        _manualLoadingComplete = true;
        _arvSuccessStyle = "";
        StateHasChanged();
        break;
      case ApiResponseStates.HttpFailure:
        Notify(NotificationType.Error, "You don't seem to be connected. Please check your Internet connection and try again");
        onNotSuccess?.Invoke(response.Message);
        break;
      case ApiResponseStates.Failure:
        if (response.Message.Contains($"{HttpStatusCode.Unauthorized}") || response.Message == "HTTP error (Unauthorized) You are not authenticated") {
          // TODO AYS - How do we handle this case if changeStateOnNotSuccess is true? We don't have an ApiResponseStates value for not authenticated
          Notify(NotificationType.Error, "Your session has expired, so you need to log in again", onClick: () => NavigationManager.NavigateTo($"{NavigationManager.ToAbsoluteUri(ApiResponseViewConfig.LogInUrl)}?returnUrl=/{Uri.EscapeDataString(NavigationManager.ToBaseRelativePath(NavigationManager.Uri))}", forceLoad: true));
          onNotSuccess?.Invoke(response.Message);
        } else {
          if (changeStateOnNotSuccess) {
            _apiResponse = new ApiResponse<T>(ApiResponseStates.Failure, Message: response.Message);
          } else {
            Notify(NotificationType.Error, response.Message);
            onNotSuccess?.Invoke(response.Message);
          }
        }
        break;
      case ApiResponseStates.ServiceUnavailable:
        if (changeStateOnNotSuccess) {
          _apiResponse = new ApiResponse<T>(ApiResponseStates.ServiceUnavailable);
        } else {
          Notify(NotificationType.Error, "An update is currently in progress. The average update time is under 2 minutes. Please try again soon");
          onNotSuccess?.Invoke(response.Message);
        }
        break;
      default:
        throw new ArgumentException($"Unexpected state: {response.State}");
    }
  }

  public void Notify(NotificationType type, string message, DateTime? dateTime = null, Action? onClick = null) {
    if (FeedbackType == ApiResponseViewFeedbackType.Notifications) {
      NotificationHelper.Send(type, message, dateTime ?? DateTime.Now, onClick);
    } else {
      Message = message;
    }
  }

}

